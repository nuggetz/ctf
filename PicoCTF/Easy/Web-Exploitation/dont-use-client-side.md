#easy #web 

# dont-use-client-side Walkthrough

<img width="474" alt="dont-use-client-side - dash" src="https://github.com/user-attachments/assets/99783d21-2711-47ae-b48b-a6a2eb19a75f" />


This challenge provides a valuable security lesson in its title: **“Don’t Use Client-Side”**. It suggests that sensitive operations or logic shouldn’t be handled on the client side, as it can be easily accessed and exploited.


### Step 1: Visiting the Site

Clicking the provided link takes us to a simple webpage with a “secure” login portal. At first glance, it seems like a typical password verification system.

<img width="368" alt="dont-use-client-side - site" src="https://github.com/user-attachments/assets/e891dea7-e679-4cd9-a41c-f2060666d8f2" />


### Step 2: Inspecting the Code

Following standard reconnaissance steps, I open the **browser inspector** to analyze the website’s structure and functionality.

Within the JavaScript code, I find the following password verification logic:

```js
  function verify() {
    checkpass = document.getElementById("pass").value;
    split = 4;
    if (checkpass.substring(0, split) == 'pico') {
      if (checkpass.substring(split*6, split*7) == '****') {
        if (checkpass.substring(split, split*2) == 'CTF{') {
         if (checkpass.substring(split*4, split*5) == 'ts_p') {
          if (checkpass.substring(split*3, split*4) == 'lien') {
            if (checkpass.substring(split*5, split*6) == 'lz_7') {
              if (checkpass.substring(split*2, split*3) == 'no_c') {
                if (checkpass.substring(split*7, split*8) == 'e}') {
                  alert("Password Verified")
                  }
                }
              }
      
            }
          }
        }
      }
    }
    else {
      alert("Incorrect password");
    }
    
  }
```


### Step 3: Understanding the Vulnerability

By examining the code, it’s clear that the **entire password verification process** happens on the client side. This means the password logic and even the password itself are exposed to anyone inspecting the source code.

The password is broken into pieces and verified step by step using substring(). The pieces are:

1. `pico`
2. `CTF{`
3. `no_c`
4. `lien`
5. `ts_p`
6. `lz_7`
7. `****`
8. `e}`


### Step 4: Assembling the Flag

Using the information in the JavaScript code, we can reconstruct the password by combining the pieces in the correct order:

`picoCTF{no_clients_plz_7****e}`


### Lesson Learned: Avoid Client-Side Verification

This challenge highlights why critical operations, like password verification, should **never** be done on the client side.

• **Why it’s insecure:**
Any user can inspect the client-side code and reverse-engineer the logic, bypassing the intended security measures.

• **Best Practices:**
Password verification and sensitive operations should always happen on the **server side**, where the logic and data remain hidden from the end user.


### Conclusion

This challenge was a straightforward but important reminder about web application security. Ensuring critical logic remains on the server side is a fundamental practice to prevent such vulnerabilities.

See you in the next challenge!
